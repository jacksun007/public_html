<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01//EN"
            "http://www.w3.org/TR/html4/strict.dtd">
<html>

<head>
<meta http-equiv="Content-Type" content="text/html;charset=utf-8">
<title>
Operating Systems, ECE344, Winter 2020
</title>
  <link title="compact" rel="stylesheet" type="text/css" href="default.css">
</head>

<body>
<table class="maintable">
<tr>

<td class="left">
<img src="spacer.gif"  alt="" height="1" width="200">
Instructor: <a href="http://www.eecg.toronto.edu/~yuan/">Ding Yuan</a><br>
Course Number: ECE344<br>
<a class="invisible" href="http://validator.w3.org/check?uri=referer">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</a>
<h2></h2>
<a href="index.html">Home</a><br>
<a href="https://piazza.com/utoronto.ca/winter2020/ece344/home">Discussion (Piazza)</a><br>
<a href="lab-documentation.html">Lab Documentation</a><br>
<a href="lab-assignments.html"><b>Lab Assignments</b></a><br>
<a href="lectures.html">Schedule and Lecture Notes</a><br>
<a href="https://portal.utoronto.ca">Grades (Quercus)</a><br>
</td>

<td class="right">
<div class="centeralign">
<h1>Operating Systems</h1>
<h2 class="noborder">ECE344, Winter 2020<br>
University of Toronto</h2>
<br>
</div>

<div class="main">

<h2>Assignment 4: Virtual Memory</h2>

<p>
<b>Release date</b>: Mar 20<br>
<b>Due date</b>: Apr 13, 11:59 pm.<br>
</p>

<h3>Objectives</h3>

<p>After this assignment, you should:</p>

<ul>
<li>Become familiar with OS handling of TLB and page faults.</li>
<li>Develop a solid intuition about virtual memory and what it means to support
it.</li>
</ul>

<h3>Introduction</h3>

<p>You have improved OS161 to the point that you can now run user
processes. However, there are a number of shortcomings in the current system. A
process's size is limited by the number of TLB entries (i.e., 64 pages). In
addition, while <tt>kmalloc()</tt> correctly manages sub-page allocations
(i.e. memory requests for under <tt>4KB</tt>), a page that is allocated is not
returned to the system, severely limiting the lifetime of your system.</p>

<p>In this assignment we will adapt OS161 to take full advantage of the
simulated hardware by implementing management of the MIPS software-managed
Translation Lookaside Buffer (TLB). You will write the code to manage this
TLB. You will also correctly handle page reclamation, allowing your system to
reclaim memory when processes exit. Finally, you will also write the code to
implement demand paging, i.e., the mechanism by which memory pages of an active
process are loaded on demand from disk, sent back to disk when memory is needed,
and restored to memory when required by the program. This permits many processes
to share limited physical memory while providing each process with the
abstraction of a very large virtual memory.</p>

<h4>Structure of the TLB entries</h4>

<p>In the System/161 machine, each TLB entry includes a 20-bit virtual page
number and a 20-bit physical page number as well as the following five
fields:</p>

<ul>
<li>
<tt>global</tt>: 1 bit; if set, ignore the <tt>pid</tt> bits in the TLB.</li>
<li><tt>valid</tt>: 1 bit; set if the TLB entry contains a valid
translation.</li>
<li><tt>dirty</tt>: 1 bit; enables writing to the page referenced by the entry;
if this bit is 0, the page is only accessible for reading.</li>
<li><tt>nocache</tt>: 1 bit; unused in System/161. In a real processor,
indicates that the hardware cache will be disabled when accessing this
page.</li>
<li><tt>pid</tt>: 6 bits; a context or address space ID that can be used to
allow entries to remain in the TLB after a context switch.</li>
</ul>

<p>All these bits/values are updated by the operating system. When
the <tt>valid</tt> bit is set, the TLB entry contains a valid translation. This
implies that the virtual page is present in physical memory. A <b>TLB miss</b>
occurs when no TLB entry can be found with a matching virtual page and address
space ID (unless the global bit is set in which case the address space ID is
ignored) with the valid bit set.</p>

<h4>Paging</h4>

<p>The operating system creates the illusion of unlimited memory by using
physical memory as a cache of <b>virtual pages</b>. Paging relaxes the
requirement that all the pages in a process's virtual address space must be in
physical memory. Instead, we allow a process to have pages either on disk or in
memory. When the process issues an access to a page that is on disk, a <b>page
fault</b> occurs. The operating system must retrieve the page from disk and
bring it into memory. Pages with valid TLB entries are always in physical
memory. This means that a reference to a page on disk will always generate a TLB
fault. At the time of a TLB fault, the hardware generates a TLB exception,
trapping to the operating system. The operating system then checks its own page
table to locate the virtual page requested. If that page is currently in memory
but wasn't mapped by the TLB, then all we need to do is update the TLB. However,
the page might be on disk. If this is the case, the operating system must:</p>

<ol>
<li>Allocate a place in physical memory to store the page.</li>
<li>Read the page from disk.</li>
<li>Update the page table entry with the new virtual-to-physical address
translation.</li>
<li>Update the TLB to contain the new translation.</li>
<li>Resume execution of the user program.</li>
</ol>

<p>Notice that when the operating system selects a location in physical memory
in which to place the new page, the space may already be occupied. In this case,
the operating system must <b>evict</b> that other page from memory. If the page
has been modified or does not currently have a copy on disk, then the old page
must first be written to disk before the physical page can be reallocated. If
the old page has not been modified and already has a copy on disk, then the
write to disk can be avoided. The appropriate page table entry must be updated
to reflect the fact that the page is no longer in memory.</p>

<p>As with any caching system, the performance of your virtual memory system
depends on the policy used to decide which things are kept in memory and which
are evicted. On a page fault, the kernel must decide which page to
replace. Ideally, it will evict a page that will not be needed soon. Many
systems (such as UNIX) avoid the delay of synchronously writing memory pages to
disk on a page fault by writing modified pages to disk in advance so that
subsequent page faults can be completed more quickly. Typically, this process is
  performed by a separate paging thread.
</p>

<h4>Your Mission</h4>

<ul>
  <li>Part 1
    <ul>
      <li>Implement the code that services TLB faults.</li>
      <li>Implement the code to correctly allocate and deallocate kernel
        memory.</li>
    </ul>
  </li>
  <li>Part 2
    <ul>
      <li>Implement the first piece of demand paging, demand loading of pages,
        so that the operating system loads pages from disk on demand.</li>
      <li>Add the <tt>sbrk()</tt> system call, so that user-level <tt>malloc()</tt> works.</li>
    </ul>
  </li>
  <li>Part 3
    <ul>
      <li>Implement the second piece of demand paging, swapping, so that the
        operating system can evict pages to disk when it runs out of
        memory.</li>
    </ul>
  </li>
  <li>Part 4
    <ul>
      <li>Implement copy-on-write so that a child and parent can share pages
        after <tt>fork</tt> until one of them writes to a shared page.</li>
    </ul>
  </li>  
  <li>Part 5 (Optional)
    <ul>
      <li>Implement a paging thread that evicts dirty pages in advance so that
        page faults can be serviced without requiring disk I/O.</li>
      <li>Tune the performance of your virtual memory system by optimizing the
        TLB and page replacement algorithms.</li>
    </ul>
  </li>
</ul>

<p>You will be tested on the five different parts above. Be warned that the last
few parts may require significant time investment so do start <em>early</em>. </p>

<h3>Begin your assignment</h3>

<p>Consult the ASST4 config file and notice that
the <tt>arch/mips/mips/dumbvm.c</tt> file will be omitted from your kernel. You
will undoubtedly need to add new files to the system for this assignment,
e.g., <tt>kern/vm/vm.c</tt>. Be sure to update the
file <tt>kern/conf/conf.kern</tt>, or, for machine-dependent
files, <tt>kern/arch/mips/conf/conf.arch</tt>, to include any new files that you
create. Take care to place files in the "correct" place, separating
machine-dependent components from machine-independent components.</p>

<p>You should also now restrict your physical memory to 512 KB by editing
the <tt>ramsize</tt> line in your <tt>sys161.conf</tt> file.</p>

<p>Now, tag your repository exactly as shown below:</p>

<pre>  
% git tag asst4-start
% git push --tags
</pre>

<p>Next configure and build OS161 for this
assignment. The <a href="asst2.html#configure">configuration and build
instructions</a> are similar to previous assignments.</p>

<p>Now you are now ready to begin assignment 4.</p>

<h3>Design Questions</h3>

<h4>Problem 1</h4>

<p>Assuming that a user program just accessed a piece of data at (virtual)
address X, describe the conditions under which each of the following can
arise. If the situation cannot happen, explain why it cannot occur.</p>

<ul>
<li>TLB miss, page fault</li>
<li>TLB miss, no page fault</li>
<li>TLB hit, page fault</li>
<li>TLB hit, no page fault</li>
</ul>

<h4>Problem 2</h4>

<p>A friend of yours who foolishly decided not to take this course, but who
likes OS161, implemented a TLB that has room for only one entry, and
experienced a bug that caused a user-level instruction to generate a TLB fault
infinitely - the instruction never completed executing! Explain how this could
happen. (Note that after OS161 handles an exception, it restarts the
instruction that caused the exception.)</p>

<h4>Problem 3</h4>

<p>How many memory-related exceptions (i.e., hardware exceptions and other
software exceptional conditions) can the following MIPS-like instruction raise?
Explain the cause of each exception.</p>

<pre>  # load word from $0(contains zeros) offset 0x120 into register $3
  lw  $3,0x0120($0) 
</pre>

<h3>TLB Handling</h3>

<p>In this part of the assignment, you will modify OS161 to handle TLB
faults. Additionally, you need to guarantee that the TLB state is initialized
properly on a context switch. One implementation alternative is to invalidate
all the TLB entries on a context switch. The entries are then re-loaded by
taking TLB faults as pages are referenced. An alternative to invalidating the
entries is to use the 6-bit address space IDs and maintain separate entries for
each process in the TLB simultaneously. In this case, you will need to add
support for tag handling in the TLB.</p>

<p>We recommend that you separate the implementation of the TLB entry
replacement algorithm from the actual piece of code that handles the
replacement. This will make it easy to experiment with different replacement
algorithms if you wish to do so. Refer to the kernel config file section of
Assignment 2 on how to add configuration options for TLB replacement
policies.</p>

<h3>Paging</h3>

<p>In this part of the assignment, you will modify OS161 to handle page
faults. When you have completed this problem, your system will generate an
exception when a process tries to access an address that is not memory-resident
and then handle that exception and continue running the user process.</p>

<p>You will need routines to move a page from disk to memory and from memory to
disk.</p>

<p>Currently <tt>execv</tt> loads all program pages when the program is
started. Replace this implementation so that pages are loaded on
demand. Similarly, change <tt>fork</tt> to load certain pages (e.g., text pages)
on demand.</p>

<p>When the time comes to bring a page into memory, you will need to know which
physical pages are currently in use. One way to manage physical memory is to
maintain a <b>core map</b>, a sort of reverse page table. Instead of being
indexed by virtual addresses, a core map is indexed by its physical page number
and contains the virtual address and address space identifier for the virtual
page currently associated with the page in physical memory. When you need to
evict a page, you look up the physical address in the core map, locate the
address space whose page you are evicting and modify the corresponding state
information to indicate that the page will no longer be in memory. Then you can
evict the page. If the page is dirty, it must first be written to the backing
store or swap (discussed below).</p>

<p>Paging systems allow implementing copy-on-write (COW) based sharing of
pages. With copy-on-write, virtual pages share the same physical frame, until
either of the virtual page is updated. When either page is updated, a copy is
made so that the physical frames are no longer shared. You need to modify fork
so that the parent and child use copy-on-write pages. Mark a copy-on-write page
as read-only temporarily. When a write is attempted, a page fault will
occur. The page fault handler can determine that this page is temporarily
read-only because the region should be writable (e.g., stack region). At this
point, implement the page copying in the fault handler. You will need to change
the core map implementation described above to store multiple virtual address
mappings for each physical page.</p>

<p>Your paging system will also need to support page allocation requests
generated by <tt>kmalloc()</tt>. You should review <tt>kmalloc()</tt> to
understand how these requests are generated, so that your system will respond to
them correctly. Currently, pages that are allocated to <tt>kmalloc</tt> are not
returned to the system. You can use the core map to correctly implement
allocated and freed pages.</p>

<p>You will need to decide how to implement backing store (the place on disk
where you store virtual pages not currently stored in physical memory). The
default <tt>sys161.conf</tt> includes two disks; you can use one of those disks
for swapping. Please do swap to a disk and not somewhere else (such as a file).
Also, be sure not to use that disk for anything else! To help prevent errors or
misunderstandings, please have your system print the location of the swap space
when it boots. You will have to figure out how to use the swap device (hint:
use <tt>vfs_open</tt> and <tt>VOP_STAT</tt>). </p>

<p>You will need to store evicted pages and find them when you need them. You
can maintain a bitmap that describes the space in your swap area. Think of the
swap area as a collection of chunks, where each chunk holds a page. Use the
bitmap to keep track of which chunks are full and which are empty. You can evict
pages to empty chunks. For every evicted page in an address space, you need to
keep track of the chunk in the swap area that holds the page contents. When
there are too many pages to fit in physical memory, you can write (modified)
pages out to swap.</p>

<p>On a page fault, you will need to add code to check whether a page has been
swapped out. If so, the page should be read from the swap chunk and the chunk
marked as available. How do you make this code work for shared pages that are
swapped out?</p>

<p>In some systems, the writing of dirty pages to backing store is done in the
background. As a result, when the time comes to evict a page, the page itself is
usually clean (that is, it has been written to backing store, but not modified
since then). You need to implement this mechanism in OS161 by creating a thread
that periodically examines pages in memory and writes them to backing store if
they are dirty.</p>

<h3>Testing malloc() and free()</h3>

<p>Now that OS161 has paging, you can support applications with larger address
spaces.  The <tt>malloc()</tt> and <tt>free()</tt> library functions are
provided in the standard C library. Read the code and answer the following
questions:</p>

<ul>
<li><b>Question 1.</b> Consider the following (useless) program: 

<pre>/* This is bad code: it doesn't do any error-checking */
#include&lt;stdio.h&gt;
int main (int argc, char **argv) {
        int i;
        void *start, *finish;
        void *res[10];
        start = sbrk(0);
        for (i = 0; i &lt; 10; i++) {
                res[i] = malloc(10);
        }
        finish = sbrk(0);
        /* TWO */
        return 0;
}
</pre>

<ol>
<li>How many times does the system call <tt>sbrk()</tt> get called from
within <tt>malloc()</tt>?</li>
<li>On the i386 platform, what is the numeric value of <tt>(finish -
    start)</tt>?</li>
</ol>
<br></li>

<li><b>Question 2.</b> Suppose that we now insert the following code at
location <tt>/* TWO */</tt>:
<pre>        {
                void *x;
                free(res[8]); free(res[7]); free(res[6]);
                free(res[1]); free(res[3]); free(res[2]);
                x = malloc(60);  /* MARK */
        }
</pre>

Again on the i386, would <tt>malloc()</tt> call <tt>sbrk()</tt> when doing that
last allocation at the marked line above? What can you say
about <tt>x</tt>?</li>

<li><b>Question 3.</b> It is conventional for libc internal functions and
variables to be prefaced with "__". Why do you think this is so?</li>

<li><b>Question 4.</b> The man page for malloc requires that "the pointer
returned must be suitably aligned for use with any data type." How does our
implementation of malloc guarantee this?</li>
</ul>

<p>Note that the operation of <tt>malloc()</tt> and <tt>free()</tt> is a
standard job interview question -- you should understand this code!</p>

<p>You are responsible for making the <tt>malloc()</tt> we give you work. This
will involve writing an <tt>sbrk()</tt> system call.</p>

<h3>Instrumentation and Tuning</h3>

<p>In this section, we ask you to tune the performance of your virtual memory
system. As a start, we ask that you implement the following counters:</p>

<ul>
<li>The number of currently allocated physical pages.</li>
<li>The number of TLB faults.</li>
<li>The number of page faults.</li>
<li>The number of page faults that require a synchronous write of a page.</li>
<li>The total number of pages swapped over time.</li>
</ul>

<p>You should add the necessary infrastructure to maintain these statistics as
well as any other statistics that you think you will find useful in tuning your
system.</p>

<p>Once you have completed all the problems in this assignment and added
instrumentation, it is time to tune your operating system. We strongly encourage you
to create a file <tt>performance.txt</tt> as your "lab notebook" for this section (you
do not need to submit this file).</p>

<p>At a minimum, use the <tt>matmult</tt> and <tt>sort</tt> programs provided to
determine your baseline performance (the performance of your system using the
default TLB and paging algorithms). Experiment with different TLB and paging
algorithms and parameters in an attempt to improve your performance. As before,
predict what will happen as you change algorithms and parameters. Compare the
measured to the predicted results; obtaining a different result from what you
expect might indicate a bug in your understanding, a bug in your implementation,
or a bug in your testing. Figure out where the error is! We suggest that you
tune the TLB and paging algorithms separately and then together.  You may not
rewrite the <tt>matmult</tt> program to improve its performance.</p>

<p>You should add other test programs to your collection as you tune
performance, otherwise your system might perform well at matrix multiplication
and sorting, but little else. Try to introduce programs with some variation in
their uses of the memory system.</p>

<p>At the end of this assignment, we will run some test programs to
evaluate the overall performance of your virtual memory system.</p>

<h3>Testing your code</h3>

<p>By the end of this assignment, you will be able to run several programs in
the <tt>/testbin</tt> directory. In addition to the programs that should run
after assignment 3, you should be able to run <tt>huge, malloctest, matmult,
palin, parallelvm, stacktest, tripleprog</tt>, and <tt>triplemat</tt>.</p>

<p>You will need to "bullet-proof" the OS161 kernel from user program
errors. There should be nothing a user program can do to crash the operating
system (with the exception of explicitly asking the system to halt). In
particular, the <tt>forkbomb</tt> and the <tt>forkexecbomb</tt> programs should
only cause your system to run out of swap but not crash or deadlock your
kernel.</p>

<h3>Strategy</h3>

<p>The first step is understanding how TLB and page faults occur. To make this
task easier, one person in your group should study TLB faults and the other
should study page faults.</p>

<p>However, the time required to implement page fault handling is longer than
the time required to implement TLB fault handling. You should divide the virtual
memory implementation into several small and well-defined modules so that you
can both work on it as soon as one of you has completed the TLB
implementation. Get together as early as possible to share what you each have
discovered.</p>

<p>Look at the code in <tt>kern/arch/mips/mips/trap.c</tt> to see how traps are
handled by the kernel. (To see how traps are generated by the simulator, look at 
 <tt>sys161-1.14/mipseb/mips.c</tt> available from
the <a href="./os161/sources/os161-toolchain.tar.gz">OS161 toolchain</a>). Then
examine the <tt>vm_fault()</tt> handler
in <tt>os161/src/kern/arch/mips/mips/dumbvm.c</tt>. What changes must you add to
support TLB and page faults?</p>

<p>Some of the key issues are:</p>
<ul>
<li>What will your page tables look like?</li>
<li>What should you put in each PTE (page table entry)?</li>
<li>What will your core map (or reverse page table) look like?</li>
<li>In what order can TLB faults and page faults occur? For example, can a page
  fault occur without causing a TLB fault?</li>
</ul>

<p>When you have completed your initial implementation of the TLB and virtual
memory, one partner can begin experimenting with
<tt>matmult</tt> while the other writes other test programs. Stay in 
touch and test each other's code.</p>

<p>Do your best to break your partner's implementation, then help him/her fix
it. When you write test programs, think about verifying that your replacement
algorithms are working correctly (i.e., "If I run this program it should
generate exactly <em>n</em> TLB faults with your algorithm; does it?").</p>

<p>Review each other's designs. Think about how you might have implemented the
different parts and compare ideas.</p>

<p>As your system begins to stabilize, begin to work on the performance
tuning. Continue to test and fix bugs. Take turns testing and tuning. Be sure to
keep a careful log of your performance experiments so you can trade it back and
forth. Have fun, and good luck!</p>

<h3>Assignment Submission</h3>

<p>Finally, you need to submit your code for this assignment.</p>

<ol>
<li>Once you are confident that your assignment is done,
run <tt>make clean</tt> from the <tt>os161</tt> directory. This will clean all
generated files. Then use <tt>git status</tt> in the <tt>os161</tt> directory to
find out the status of all files. Make sure to commit and push all files before continuing with the submission process. Also make sure that your partner's changes are also
committed.</li>

<li>To submit your assignment, tag your repository for the end of assignment 4 and push the tags to the remote repository:

<pre>
% git tag asst4-end
% git push --tags
</pre>
</li>

<li>If you need to re-submit (before the deadline), delete the existing tag and push a new version of the tag <em>after</em> you committed your new changes:

<pre>
% git push  # push your new changes to remote repository first

% git tag -d asst4-end      # delete old tag
% git tag asst4-end         # create new tag
% git push --tags --force   # force remote repository to update to new tag
</pre>
</li>

<li>(No need to submit) We strongly encourage you to document your design in a design document.
Your design document should include the following:
  <ul>
    <li>A high level description of how you are approaching the problem.</li>
    <li>A description of the implementation (e.g., new structures, why they were
      created, what they are encapsulating, what problems they solve). How did you go
      about adding TLB handling, paging, memory allocation and deallocation, brk,
      stack growth? Provide a description of your TLB and paging algorithms.</li>
  </ul>
</li>

</ol>

<h3>Testing your assignment with the autotester</h3>
<p>Note that for this assignment, we now expect that the menu thread wait until
the child thread to finish before printing the prompt and accepting another command.
The tester will not work correctly if this feature is not implemented.
</p>

<p>Please read the <a href="testing.html">instructions for testing your code</a>. We will run identical tests to mark your assignment, so make sure to use the tester to check your progress. After submission, you are suggested to run the tester in marker mode to verify that your submission has been received correctly.
</p>
<br>
<br>

</div>
</td>
</tr>
</table>
</body>
</html>
<!-- :::!../current/html/template-end::: -->

