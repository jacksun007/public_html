<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <title>Assignment 4 | ECE326 | Programming Languages | Fall 2020</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="description" content="">
    <meta name="author" content="Kuei (Jack) Sun">
    <link href="css/bootstrap.css" rel="stylesheet">
    <link href="css/dashboard.css" rel="stylesheet">
    <!-- HTML5 shim, for IE6-8 support of HTML5 elements -->
    <!--[if lt IE 9]>
      <script src="../assets/js/html5shiv.js"></script>
    <![endif]-->
  </head>
<body data-spy="scroll" data-target=".sidebar"  data-offset="64">

<nav class="navbar navbar-dark navbar-expand-md fixed-top bg-dark shadow">
  <a class="navbar-brand pr-3" href="ece326.html">ECE326</a>
  <button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarCollapse" aria-controls="navbarCollapse" aria-expanded="false" aria-label="Toggle navigation">
    <span class="navbar-toggler-icon"></span>
  </button>
  <div class="collapse navbar-collapse" id="navbarCollapse">
    <ul class="navbar-nav mr-auto">
      <li class="nav-item">
        <a class="nav-link" href="ece326.html">Home</a>
      </li>
      <li class="nav-item">
        <a class="nav-link" href="lectures.html">Lecture Notes</a>
      </li>
      <li class="nav-item active">
        <a class="nav-link" href="labs.html">Assignments</a>
      </li>
      <li class="nav-item">
        <a class="nav-link" href="http://piazza.com/utoronto.ca/fall2020/ece326">Piazza Discussion</a>
      </li>
      <li class="nav-item">
        <a class="nav-link" href="https://q.utoronto.ca/">Quercus Website</a>
      </li>
      
    </ul>
  </div>  
</nav>

<div class="container-fluid">
  <div class="row">
    <nav class="col-md-3 col-lg-2 d-none d-md-block bg-light sidebar">
      <div class="sidebar-sticky">
        <ul class="nav flex-column">
          <li class="nav-item">
            <a class="nav-link" href="#background">
              Background
            </a>
          </li>
		  <li class="nav-item">
            <a class="nav-link" href="#remote-methods">
			   Remote Methods
		    </a>
          </li>
		  <li class="nav-item">
            <a class="nav-link" href="#setup">
              Setup
            </a>
          </li>
          <li class="nav-item">
            <a class="nav-link" href="#solution-requirements">
              Solution Requirements
            </a>
          </li>
		  <li class="nav-item">
            <a class="nav-link" href="#task-1">
              RPC Protocol
            </a>
          </li>
		  <li class="nav-item">
            <a class="nav-link" href="#task-2">
              Type-Safe RPC API
            </a>
          </li>
          <li class="nav-item">
            <a class="nav-link" href="#submission">Code Submission</a>
          </li>
        </ul>
      </div>
    </nav>

    <main role="main" class="col-md-9 ml-sm-auto col-lg-10 px-4">
      <div class="d-flex justify-content-between flex-wrap flex-md-nowrap align-items-center pt-3 pb-2 mb-3 border-bottom">
        <h2>Assignment 4: Remote Procedure Call Framework</h2>
      </div>
      <p><strong>Due Date: December 10th, 11:59pm</strong></p>
      <p><strong>Lab TA: Mike Qin</strong></p>

<p>In this assignment, you will develop a type-safe remote procedure call framework (RPC) in C++.</p>

<h4 id="background">Background</h4>

<p>In a distributed environment, you often need to invoke a procedure on another machine. Consider a member function <code>int Foo::Hash(int x)</code>, if you want to invoke it locally, you can write <code>foo.Hash(x)</code> where <code>foo</code> is an object of class <code>Foo</code> and <code>x</code> is an integer. In order to perform a remote procedure call, you would like to write in the following way:</p>

<pre>auto result = client-&gt;Call(foo, &amp;Foo::Hash, x);
client-&gt;Flush();
result-&gt;data(); // This represents the return value
</pre>

<p><code>client</code> represents a RPC client, which it's initialized before this snippet. <code>Call()</code> does not call the function immediately, instead, it encodes the function call as a network request and sends it to the RPC server. The <code>Call()</code> function is non-blocking and returns a <code>result</code> object to represent the result of the remote procedure call. The result is not available until the client calls <code>client-&gt;Flush()</code> to flush the network buffer and waits for the server to respond. After this, the result can be accessed using <code>result-&gt;data()</code>.</p>

<h4 id="remote-methods">Remote Objects and Functions</h4>

<p>Function and object pointers in a remote procedure call belong to two different address spaces. For example, addresses of <code>&amp;foo</code> and <code>&amp;Foo::Hash</code> are totally different on the client and on the server. So we need to introduce universal object and function IDs. To make this framework easier to use, objects need to inherit our <code>Service&lt;T&gt;</code> template class, where <code>T</code> is user's class name. For example, <code>class MyService : public Service&lt;MyServie&gt; ...</code>.</p>

<p>On the client, users can call <code>set_instance_id()</code> on the service object. The instance id must be consistent with the RPC server. On the RPC server, users can call <code>AddService()</code> to export a service object.</p>

<pre><code>server-&gt;AddService(new MyService(), the_instance_id);
</code></pre>

<p><code>server</code> represents an RPC server and <code>the_instance_id</code> must be consistent with the id on the client side.</p>

<p>For a given service, function IDs must also be consistent between the server and the client. Notice that both the client and the server must call the service constructor, we can construct the mapping between member functions and their IDs in the constructor. We require users to call the <code>Export()</code> function for the member function they want to RPC. For example:</p>

<pre><code>MyService::MyService()
{
    Export(&amp;MyService::Hash);
}
</code></pre>

<p>The <code>Export()</code> function keeps an internal, per-object counter to generate function IDs automatically and stores the mapping between function pointers and IDs. We require the constructor to be deterministic, and so the function IDs are consistent between the client and the server.</p>

<h4 id="setup">Setup</h4>

<pre><code>cd ~/ece326
tar -xf /cad2/ece326f/src/rpc.tar
git status # should say that "asst4/" directory is untracked
git add asst4
git commit -m "Initial code for Assignment 4"
git tag Asst4-start
git push
git push --tags
cd asst4/
</code></pre>

<p>We use googletest as a unittest framework in this assignment. Let's acquire that via a git submodule command (make sure you are inside the <code>asst4/</code> directory).</p>

<pre>
asst4% git submodule add https://github.com/google/googletest.git
</pre>

<p>For people whose partners have already checked in the starter code, do not run the above command. The submodule should have already been "added" internally. However, git requires
every local repository to initialize the submodule. So do this instead:</p>

<pre>
asst4% git pull
asst4% git submodule init
asst4% git submodule update
</pre>

<p>The starter code contain the following files:</p>

<ul>
<li><code>Makefile</code> and <code>cc.mk</code>: The build system. Type <code>make</code> to build your project. Do not modify these files.</li>
<li><code>rpc.cc</code> and <code>rpc.h</code>: Implement network infrastructure and basic RPC calling convention. Do not modify these files.</li>
<li><code>test-rpc-common.h</code>: Common code for all unittests. Do not modify this file.</li>
<li><code>test-proto.cc</code>: Unittest for task 1, which tests your implementation on how a certain type is encoded/decoded correctly. Do not modify this file.</li>
<li><code>test-simple.cc</code> and <code>test-complex.cc</code>: Unittest for task 2, which tests your implementation of the type-safe RPC API. Do not modify these files.</li>
<li><code>rpcxx.h</code>: This is an example implementation for you to start. <em>You should modify this file only.</em></li>
</ul>

<p>To compile, simply type <code>make</code>, i.e.:

<pre>
cd ~/ece326/asst4
make
</pre>

<p>Note that <tt>test-proto.cc</tt> and <tt>test-complex.cc</tt> will not compile at the moment. By default all unittests are generated under the <code>Release/</code> directory. For debug build, you can <code>make BUILD=Debug</code>.</p>

<!--It does not implement the protocol of how to encode/decode a certain type, which is task 1 of this assignment. -->

<h4 id="solution-requirements">Solution Requirements</h4>

<p>We breakdown this lab into two tasks. Both of them must be implemented inside the <code>rpcxx.h</code> file. An example implementation is given.</p>

<p>With the example implementation, only <code>test-simple</code> compiles. Both tasks require your code to compile with all unittests. Upon a successful compilation, you can run test binaries under the output directory for test results, for example:</p>

<pre><code>Release/test-simple
</code></pre>

<h5 id="task-1">Task 1: Protocol for Parameter and Result Types</h5>

<p>The RPC library needs to encode/decode function parameters and function return values from the network. Currently, this implementation is missing, and your first task is to write a template class <code>Protocol</code> to implement this.</p>

<p>We need to support the following types: <code>int</code>, <code>bool</code>, <code>char</code>, <code>short</code>, <code>long</code>, 
<code>long long</code>, <code>float</code>, <code>double</code>, 
and <code>std::string</code>. You also need to support all the unsigned integer types (e.g., <code>unsigned int</code>, <code>unsigned char</code>, etc).
</p>

<p>The example code provide the <code>Protocol&lt;T&gt;</code> definition. Your task is to specialize the <code>Protocol</code> class for each supported type. Each specialization must support two functions: <code>Encode()</code> and <code>Decode()</code>. Both must check if the input/output buffer has enough allocated size for encoding or decoding. The example code contain a sample implementation for <code>int</code>.</p>

<p><code>test-proto</code> unittest contains all test cases you need to pass for this task. The example <code>rpcxx.h</code> should pass some of them.</p>

<p>Similar to assignment 1, you need to convert multi-byte native data types to <em>network byte order</em> (which is big-endian). On Linux systems, you may use following functions to convert between
host byte order (the byte order on the current CPU) and big-endian byte order.</p>

<ul>
<li><code>short</code>: use <a href="https://linux.die.net/man/3/htobe16">htobe16</a> or <a href="https://linux.die.net/man/3/htons">htons</a> to convert <em>to</em> a 16-bit big-endian byte-order, and 
    <a href="https://linux.die.net/man/3/be16toh">be16toh</a> or <a href="https://linux.die.net/man/3/ntohs">ntohs</a> to convert <em>from</em> a 16-bit big-endian byte-order to host byte order.</li>
<li><code>int, float</code>: use <a href="https://linux.die.net/man/3/htobe32">htobe32</a> or <a href="https://linux.die.net/man/3/htonl">htonl</a> to convert <em>to</em> a 32-bit big-endian byte-order, and 
    <a href="https://linux.die.net/man/3/be32toh">be32toh</a> or <a href="https://linux.die.net/man/3/ntohl">ntohl</a> to convert <em>from</em> a 32-bit big-endian byte-order to host byte order.</li>
<li><code>long long, double</code>: use <a href="https://linux.die.net/man/3/htobe64">htobe64</a> to convert <em>to</em> a 64-bit big-endian byte-order, and 
    <a href="https://linux.die.net/man/3/be64toh">be64toh</a> to convert <em>from</em> a 64-bit big-endian byte-order to host byte order.</li>
</ul>

<p>For the unsigned integer types, use the same functions as the signed integer types of the same size. e.g. <code>htobe16</code> for <code>unsigned short</code> and <code>htobe64</code> for 
<code>unsigned long long</code>.</p>

<p>Note that <code>sizeof(char)</code> is 1, so it is not a multi-byte data type. Also, strings are byte arrays, and thus have no associated byte order either. In short, 
you do not need to perform byte order conversion for the <code>char</code> and <code>std::string</code> types.</p>

<p><code>long</code> is an odd case because it can either be 4 or 8 bytes, depending on CPU architecture. You should use the <em>appropriate</em> conversion function
based on the result of <code>sizeof(long)</code>, which will return 4 on 32-bit architectures, and 8 on 64-bit architectures. Similarly, <code>bool</code> is compiler-dependent, so it can
be anywhere from 1 to 8 bytes. Note that the <code>sizeof</code> operator returns a <em>compile-time constant</em>. Hint: you can make 4 template specializations to handle each of the possible byte sizes, then each specialization of the <code>Protocol</code> class can just use one of the 
4 specializations (except for <code>std::string</code>. To do so, you will need to know how to convert to a <a href="https://en.cppreference.com/w/cpp/language/pointer#Pointers_to_void">generic pointer type</a>: <code>void *</code>. </p> 

<h5 id="task-2">Task 2: Type-Safe RPC API</h5>

<p>In this task, you will implement APIs needed for type-safe RPC. The basic RPC layer is given to you with several functions missing. Your task is to implement these missing parts.</p>

<p>On the server side, the <code>Server</code> class is complete. The missing part is the <code>Service&lt;Svc&gt;::Export()</code> function. This function should take any member function of the class <code>Svc</code>, and register the member function as a possible RPC by calling <code>ExportRaw()</code>. The first parameter of <code>ExportRaw()</code> is the member function pointer, which need to be casted into <code>void *</code> type. The second parameter of <code>ExportRaw()</code> is a <code>BaseProcedure</code> object, which describes how to decode this member function from the network depending on its type. This is done by overriding the <code>DecodeAndExecute()</code> virtual function in a subclass.</p>

<p>Currently, an incomplete solution is given to you. This solution only works for member functions that takes one integer and returns an integer. Thus the inherited <code>BaseProcedure</code> class is called <code>IntIntProcedure&lt;Svc&gt;</code>. For this specific type of member functions, <code>IntIntProcedure&lt;Svc&gt;::DecodeAndExecute()</code> decodes one integer from the input stream, converts the <code>void * func_ptr</code> to its original member function type and executes it. Finally, based on its return value type, it encodes one integer to the output stream.</p>

<p>Notice that the <code>DecodeAndExecute()</code> has similar semantic with <code>Protocol&lt;T&gt;::Decode()</code>. This function returns false if the buffer <code>in_len</code> isn't large enough or any fatal error happens during parsing.</p>

<p>On the client side, the networking part is complete. You need to implement the <code>Client::Call()</code> function, which converts the member function and its parameters into network data and then sends over the network. This function takes many parameters. The first parameter is the service pointer, the second is the member function you want to RPC. After these, depending on the type of the member function, <em>this function takes all parameters you need to pass into the member function</em>. The return type also depends on the type of the member function. It needs to inherit the <code>BaseResult</code> class and its <code>data()</code> function should return the result of the corresponding type type on the client-side when ready.</p>

<p>The <code>BaseClient::Send()</code> function can help you implement this task. This function takes an instance ID, a function ID, a <code>BaseParams</code> that describes how to encode function parameters and a <code>BaseResult</code> that describes how to decode result. <code>BaseParams::Encode()</code> virtual function describes how to encode parameters into the network buffer and <code>BaseResult::HandleResponse()</code> describes how to decode result from the network buffer.</p>

<p>In the incomplete implementation that's given to you, since it only supports member functions that takes one integer and returns an integer, both the <code>IntResult</code> (<code>BaseResult</code>) and <code>IntParam</code> (<code>BaseParams</code>) only support one integer.</p>

<p>Please refer <code>rpcxx-sample.h</code> for further details.</p>

<p>There are two unit-tests for this task. First, <code>test-simple</code> should compile and pass for <code>rpcxx-sample.h</code> that's given to you. You should use this as a regression test. Second, you need to pass <code>test-complex</code>, which is a more complicated test. The sample solution <strong>cannot</strong> compile with <code>test-complex</code> yet.</p>

<h5>Recommended Coding Style</h5>

<p>This project uses <a href="https://google.github.io/styleguide/cppguide.html">Google C++ Coding Style</a> extensively. I recommend following this style. Note that you will not be marked on your coding style; this is simply a suggestion.</p>

<h4 id="submission">Submission</h4>

<p>To submit your code with the current commit, use the <code>Asst4-end</code> tag. Remember to push the new tag to the remote repository.</p>

<pre><code>git tag Asst4-end    // Creates tag for current submission for Assignment 4
git push --tags
</code></pre>
      
      <hr>
      <footer class="container text-center">
        <p>&copy; 2020 Kuei (Jack) Sun, University of Toronto</p>
      </footer>
    </main>
  </div>
</div>

<script src="js/jquery-3.4.1.min.js"></script>
<script src="js/bootstrap.min.js"></script>
<script type="text/javascript">
  $(document).ready(function() {
    /* nothing for now */
  });
</script>
</body>
</html>
