<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <title>Assignment 3 | ECE326 | Programming Languages | Fall 2019</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="description" content="">
    <meta name="author" content="Kuei (Jack) Sun">
    <link href="css/bootstrap.css" rel="stylesheet">
    <link href="css/dashboard.css" rel="stylesheet">
    <!-- HTML5 shim, for IE6-8 support of HTML5 elements -->
    <!--[if lt IE 9]>
      <script src="../assets/js/html5shiv.js"></script>
    <![endif]-->
  </head>
<body data-spy="scroll" data-target=".sidebar"  data-offset="64">

<nav class="navbar navbar-dark navbar-expand-md fixed-top bg-dark shadow">
  <a class="navbar-brand pr-3" href="ece326.html">ECE326</a>
  <button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarCollapse" aria-controls="navbarCollapse" aria-expanded="false" aria-label="Toggle navigation">
    <span class="navbar-toggler-icon"></span>
  </button>
  <div class="collapse navbar-collapse" id="navbarCollapse">
    <ul class="navbar-nav mr-auto">
      <li class="nav-item">
        <a class="nav-link" href="ece326.html">Home</a>
      </li>
      <li class="nav-item">
        <a class="nav-link" href="lectures.html">Lecture Notes</a>
      </li>
      <li class="nav-item active">
        <a class="nav-link" href="labs.html">Assignments</a>
      </li>
      <li class="nav-item">
        <a class="nav-link" href="http://piazza.com/utoronto.ca/fall2019/ece326">Piazza Discussion</a>
      </li>
      <li class="nav-item">
        <a class="nav-link" href="https://q.utoronto.ca/">Quercus Website</a>
      </li>
    </ul>
  </div>  
</nav>

<div class="container-fluid">
  <div class="row">
    <nav class="col-md-3 col-lg-2 d-none d-md-block bg-light sidebar">
      <div class="sidebar-sticky">
        <ul class="nav flex-column">
          <li class="nav-item">
            <a class="nav-link" href="#background">
              Background
            </a>
          </li>
          <li class="nav-item">
            <a class="nav-link" href="#easydb">
              EasyDB
            </a>
            <ul class="nav flex-column">
              <li class="nav-item">
                <a class="nav-link" href="#schema">
                Database Schema
                </a>
              </li>
              <li class="nav-item">
                <a class="nav-link" href="#protocol">
                Access Protocol
                </a>
              </li>
            </ul>
          </li>
          <li class="nav-item">
            <a class="nav-link" href="#setup">
              Setup
            </a>
          </li>
          <li class="nav-item">
            <a class="nav-link" href="#specification">
              Solution Requirements
            </a>
            <ul class="nav flex-column">
              <li class="nav-item">
                <a class="nav-link" href="#client">
                Database Client
                </a>
              </li>
              <li class="nav-item">
                <a class="nav-link" href="#orm_schema">
                Database Model
                </a>
              </li>
              <li class="nav-item">
                <a class="nav-link" href="#methods">
                Table Methods
                </a>
              </li>
              <li class="nav-item">
                <a class="nav-link" href="#custom_types">
                Custom Types
                </a>
              </li>                     
            </ul>
          </li>
          <li class="nav-item">
            <a class="nav-link" href="#submission">Code Submission</a>
          </li>
          <li class="nav-item">
            <a class="nav-link" href="#glossary">Glossary of Terms</a>
          </li>
        </ul>
      </div>
    </nav>

    <main role="main" class="col-md-9 ml-sm-auto col-lg-10 px-4">
      <div class="d-flex justify-content-between flex-wrap flex-md-nowrap align-items-center pt-3 pb-2 mb-3 border-bottom">
        <h1 class="h2">Assignment 3: Object-Relational Mapping</h1>
      </div>
      <p><strong>Due Date: November 17th, 11:59pm</strong></p>
      <p><strong>Lab TA: Jeffrey Fang</strong></p>
      <p>In this assignment, you will develop an object relational mapping (ORM) framework for EasyDB&trade; in Python.</p>
      
      <h4 id="background">Background</h4>
      
      <p>Object-relational mapping is a technique for converting database records to and from in-memory objects. Therefore, instead of writing code that extract values from a database query such as this:</p>
      
<pre>
# returns a Record object
rec = db.execute("GET 2 FROM User")
if rec.valid():
    name = rec["firstName"]
</pre>      

      <p>into this:</p>

<pre>
# returns a User object
try:
    user = User.get(db, id=2)
    name = user.firstName
except ObjectDoesNotExist:
    pass
</pre>    

      <p>The main advantage of an ORM layer is that it abstracts away the underlying database implementation, allowing you possible freedom to switch your database solution to another (e.g. from EasyDB to MySQL &#x1f622;).</p>
      
      <p>Another important advantage is that ORM can help you convert to and from in-memory types to storage types seamlessly. For example, some relational databases, such as EasyDB, do not natively support an IP Address type. Therefore, to store an IP address in these databases, it must first be converted to an string (e.g. "127.0.0.1"). Similarly, some unmarshalling code is required to read it back from the database. These tedious tasks can be automated with ORM.</p>
      
      <h4 id="easydb">EasyDB</h4>
      
      <p>EasyDB is a toy relational database that provides minimalistic features for managing structured data. In a relational database, data is organized into tables of columns and rows. A column in a database table is a set of data of a primitive type (that is supported by the database). A table is defined with a list of one or more named columns before any data can be inserted. A row is a set of related data that is given meaning through the table it exists in. To insert a row into a table, each value of the row must have the same type as what is defined in the table, in the same order. Also, the number of values in a row must be exactly equal to the number of columns defined in the table. For example, a User table may have the columns: <tt>firstName</tt>, <tt>lastName</tt>, <tt>height</tt> and <tt>age</tt>. A row in a User table may be ("Jay", "Sung", 5.5, 31), which correctly represents a single user in this table. A table, of course, can have many rows, allowing you to store multiple users in a User table. 
      
      <h4 id="schema">Database Schema</h4>
      
      <p>There can also be multiple tables in a relational database, allowing tables to reference others. To specify the database schema (i.e. list of table definitions) in EasyDB, use the following syntax:</p>
      
      <p><var>table-name</var> {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;<var>column-name-1</var> : <var>type | table-specifier</var>;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;<var>column-name-2</var> : <var>type | table-specifier</var>;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;...</br>
      }
      </p>
      
      <p>In EasyDB, each column in a table can be one of four types: <tt>integer</tt>, <tt>float</tt>, <tt>string</tt>, or foreign key (i.e. a "pointer" to a record in another table). To specify a foreign key type, use the name of the referenced table. The names of a table or column must start with a letter, followed by letters (either case) or numbers; underscore is not allowed. Also, the name of a column cannot be id (explained below). Here is an example of a complete database schema:</p>
      
<pre>
User {
  firstName: string;
  lastName: string;
  height: float;
  age: integer;
}

Account {
  user: User;
  type: string;
  balance: float;
}
</pre>      
      
      <p>In the definitions above, we have two tables: User and Account. For every user, we track his/her names, height, and age. For an account, we store the account type and its balance. But most importantly, an account references the User table. <tt>user</tt> stores the <em>id</em> of a row in the User table. Every row in EasyDB has an automatically generated unique integer id value which allows the row to be unambiguously referenced. In this manner, a user can have zero or more associatd accounts. EasyDB currently disallows cycles in foreign keys. Here are two examples where a cycle occurs:</p>

<pre>
# not allowed in EasyDB
User {
  firstName: string;
  lastName: string;
  father: User;
  mother: User;
}
</pre>

<pre>
# also not allowed in EasyDB
User {
  firstName: string;
  lastName: string;
  pet: Animal;
}

Animal {
  species: string;
  owner: User;
}
</pre>  
      
      <h4 id="protocol">Access Protocol</h4>
      
      <p>To access a running EasyDB server, you must know the host name and its port number. Once you are connected, you can make one of five EasyDB queries that is available. Note that EasyDB assumes that the client (the program that is connected to the server) is aware of the current schema and does not provide an API for introspection. EasyDB uses binary format as its mean of communication. Therefore, we describe common structures in the network packets that are used in EasyDB. All structures are defined using C syntax and assumed to be 4-byte aligned, with <tt>int</tt> being 32-bit signed integer, and <tt>long</tt>being 64-bit signed integer. All integers are in <a href="https://en.wikipedia.org/wiki/Endianness">network byte order</a>.</p>
      
<pre>
enum Command {
    INSERT = 1,
    UPDATE = 2,
    DROP = 3,
    GET = 4,    
    SCAN = 5,
};
</pre>

<pre>
struct request {
    int command;  /* one of Command */
    int table;    /* table number */
};
</pre>

<pre>
enum Code {
    OK = 1,
    NOT_FOUND = 2, /* id not found */
    BAD_TABLE = 3, /* table not found */
    BAD_QUERY = 4, /* error during scan */ 
    TXN_ABORT = 5, /* update aborted */
    
};
</pre>

<pre>
struct response {
    int code;      /* one of Code */
};
</pre>

      <p>All EasyDB requests begin with <tt>request</tt>. The <tt>command</tt> field is one of the five commands listed above, and the <tt>table</tt> field is the table number. A table's number is the order in which it appears in the schema, starting at 1 (in earlier example, User's table number would be 1, and Account's would be 2). All responses begin with <tt>response</tt>, which contains a code for success (i.e. OK), or error. <tt>BAD_TABLE</tt> is possible for all EasyDB commands.</p>
 
<pre>
enum Column {
    INTEGER = 1,
    FLOAT = 2,
    STRING = 3,
    FOREIGN = 4,
};
</pre>

<pre>
struct value {
    int type;     /* one of Column */
    int size;     /* size of buf */
    char buf[];   /* data stored within */
};
</pre>

<pre>
struct row {
    int count;    /* number of elements in values */
    struct value values[];
};
</pre>

      <p>In some packets, we need to send a generic value, or a row of values. In these packets, <tt>struct value</tt> and <tt>struct row</tt> would be used. <tt>struct value</tt> contains the column type (<tt>type</tt>), the size of the buffer that is needed to store the value (<tt>size</tt>), and the buffer itself (<tt>buf</tt>). For all column types, size is equal to 8 (i.e. 8 bytes) except for <tt>string</tt>, which stores a cstring in multiples of 4 bytes. Therefore, the size of the buffer for "bad" would be 4 bytes, but 8 bytes for "good" (since the null character needs to be placed in the 5th byte). For <tt>struct row</tt>, <tt>count</tt> specifies how many values are stored.</p>

      <h5>Atomic Update</h5>

<pre>
struct key {
    long id;      /* id of the row */
    long version; /* version of the row */
};
</pre>

      <p>EasyDB supports a primitive version of <em>atomic update</em>. In a concurrent environment, atomic update ensures that changes made to a row will not conflict with changes made by others. In EasyDB, updating a piece of data requires retrieving the initial data followed by modifying it in some ways. For example, to withdraw $100 from an account, one needs to first know the current balance, and then deduct $100 from it. However, there is a window of time between two EasyDB commands where it is possible that someone else makes some changes to the same row. For example, the following problem may occur:</p>
      
<pre>
      You            Your Mom     EasyDB
  GET balance ---------------------->
                   GET balance ----->
                       1000    <-----
     1000     <----------------------
                  (deposit $500)
                SET balance 1500 --->
(withdraw $100)            
SET balance 900 -------------------->            
</pre>

      <p>As you can see above, your final balance is supposed to be $1400. However, due to problematic interleaving of the commands, the deposit made by your mother was lost. EasyDB protects from this situation by having a version number associated with every row. When you make an update, you pass the version number of the row that you were modifying to the database. If the version number mismatches with what is in the database, a conflict is detected and <tt>TXN_ABORT</tt> is returned, notifying you that your update was aborted, as seen in the figure below.</p>

<pre>
      You            Your Mom       EasyDB
  GET balance ---------------------->
                   GET balance ----->
                       1000  <------- v1
     1000   <------------------------ v1
                  (deposit $500)
                SET balance 1500 ---> v2
(withdraw $100)            
SET balance 900 --------------------> NO
   TXN_ABORT  <----------------------           
</pre>
      <p>As the programmer, it is likely that you would put an atomic update in a loop so that you can retry if abort occurs.</p>      
      
      <p>We will now describe the format of each EasyDB query.</p>
      
      <h5>Insert Command</h5>
      
      <div class="table-responsive">
      <table class="packet">
        <tr>
          <td>struct request</td><td>struct row</td>
        </tr>
      </table>
      </div>
      
      <p>The insert command adds a new row to a database table. Its request packet starts with a <tt>request</tt> structure, followed by a <tt>row</tt> structure, which contains one or more rows. For the User table example, the following is an illustration of the packet that is sent to the server:</p>
      
      <div class="table-responsive">
      <table class="packet">
        <tr>
          <td>command: INSERT<br>table: 1</td>
          <td>count: 4</td>
          <td>type: string<br>size: 4<br>buf: "Joe"</td>
          <td>type: string<br>size: 8<br>buf: "Sung"</td>
          <td>type: float<br>size: 8<br>buf: 5.5</td>
          <td>type: integer<br>size: 8<br>buf: 31</td>
        </tr>
      </table>
      </div>
 
      <p>Next, the response packet is formatted as shown below:</p>
 
      <div class="table-responsive">
      <table class="packet">
        <tr>
          <td>struct response</td><td>struct key</td>
        </tr>
      </table>
      </div>

      <p>Note that <tt>struct key</tt> only appears if the response code is <tt>OK</tt>.
 
      <h5>Update Command</h5>
 
      <p>The update command is used to update an existing row in a table. It is similar to insert, with the addition that <tt>struct key</tt> of the row needs to be specified. If you don't care about atomic update, set <tt>version</tt> of <tt>struct key</tt> to 0.</p>
      
      <div class="table-responsive">
      <table class="packet">
        <tr>
          <td>struct request</td><td>struct key</td><td>struct row</td>
        </tr>
      </table>
      </div>

      <div class="table-responsive">
      <table class="packet">
        <tr>
          <td>struct response</td><td>long version</td>
        </tr>
      </table>
      </div>

      <p>The response for the update command is similar to insert, except only the new version number is returned. <tt>NOT_FOUND</tt> is returned if the row is not found. <tt>TXN_ABORT</tt> is returned if atomic update failed.</p>
 
      <h5>Drop command</h5>
      
      <p>The drop command deletes a row in table. Therefore, it needs to specify the id of the row to be dropped. In EasyDB, the drop command performs <em>cascade delete</em>, which means that if a row is referenced by rows in other tables, those rows will also be deleted. For example, if a user has three associated accounts, upon deleting the user, all associated accounts will be deleted as well. This design ensures that there will be no dangling pointers in the database.</p>
      
      <div class="table-responsive">
      <table class="packet">
        <tr>
          <td>struct request</td><td>long id</td>
        </tr>
      </table>
      </div>
      
      <p>The response packet for drop is just <tt>struct response</tt>. <tt>NOT_FOUND</tt> is returned if the row is not found.</p>
      
      <h5>Get Command</h5>
      
      <p>The get command retrieves a row from a table, which requires specifying the id of the row.</p>
      
      <div class="table-responsive">
      <table class="packet">
        <tr>
          <td>struct request</td><td>long id</td>
        </tr>
      </table>
      </div>
      
      <p>The response packet, on success, will include the row and its associated version number. <tt>NOT_FOUND</tt> is returned if the row is not found.</p>
      
      <div class="table-responsive">
      <table class="packet">
        <tr>
          <td>struct request</td><td>long version</td><td>struct row</td>
        </tr>
      </table>
      </div>
      
      <h5>Scan Command</h5>

<pre>
enum Operator {
    OP_EQ = 1,  /* equal */
    OP_NE = 2,  /* not equal */
    OP_LT = 3,  /* less than */
    OP_GT = 4,  /* greater than */
};
</pre>
      
      <div class="table-responsive">
      <table class="packet">
        <tr>
          <td>struct request</td><td>int column<br>int operator<br></td><td>struct value</td>
        </tr>
      </table>
      </div>
      
      <p>The scan command compares a column of every row in a table against a value and returns the id of all rows that matched. The <tt>column</tt> field is the column number to be matched, based on the order it appears in the table definition, starting with 1. The <tt>operator</tt> field specifies how to compare against the value stored in <tt>struct value</tt>.</p>
      
      <div class="table-responsive">
      <table class="packet">
        <tr>
          <td>struct response</td><td>int count<br>long ids[]<br></td>
        </tr>
      </table>
      </div>
      
      <p>On success, the response will contain zero or more ids (zero is possible if there were no matches). <tt>BAD_QUERY</tt> is returned if one of the following errors occurred: 1) column type and value type mismatched, or 2) operator for the given type is not supported. In EasyDB, foreign key only supports <tt>OP_EQ</tt> and <tt>OP_NE</tt>. For <tt>string</tt>, <a href="https://en.cppreference.com/w/c/string/byte/strcmp">lexicographical comparison</a> is performed (e.g., "A" is less than "B" and "5" is less than "-2").</p>
      
      <h4 id="setup">Setup</h4> 
<pre>
cd ~/ece326
tar -xf /cad2/ece326f/src/easyorm.tar
git status # should say that "asst3/" directory is untracked
git add asst3
git commit -m "Initial code for Assignment 3"
git tag Asst3-start
git push
git push --tags
cd asst3
</pre>

      <h4 id="specification">Solution Requirements</h4>
      <p>This assignment has a couple of milestones, each of which can work independently and thus are worth partial marks. You and your partner should take on one of each part of the assignment.</p>
      
      <h4 id="client">Database Client</h4>
      <p>In order to communicate with the database server, we need to write a client library that will send requests to an EasyDB server as well as parsing responses received from the server. We will describe the interface here.</p>
      
      <h5>Database Schema</h5>
      <p>As said earlier, the server assumes the client knows the schema, so we must supply the schema to the client to instantiate it. Here is how an ORM developer would use your EasyDB library:</p>
<pre>
import easydb

tb = (
    ("User", (                  # table_name
        ("firstName", str),     # (column_name, type)
        ("lastName", str),
        ("height", float),
        ("age", int),
    )),
    
    ("Account", (
        ("user", "User"),       # (column_name, table_reference)
        ("type", str),
        ("balance", float),
    ))
)

db = easydb.Database(tb)
</pre>
      <p>The above code creates a Database object. If there is an issue with the provided schema, then it should throw the following errors:</p>
      
      <ul>
        <li><tt>TypeError</tt>: thrown when either table name or column name is not a string.</li>
        <li><tt>ValueError</tt>: thrown when type is not one of str, float, int, or a string referencing another table name.</li>
        <li><tt>orm.IntegrityError</tt>: thrown when foreign keys causes a cycle.</li>
      </ul>
      
      <p>Next, we connect to the server via the <tt>connect</tt> member function.</p>
<pre>
db.connect("127.0.0.1", 8080)
</pre>
      <p><tt>connect</tt> takes two arguments, the host name and the port number. You should use Python's <a href="https://docs.python.org/3.5/library/socket.html">socket</a> library to implement this function. The function should throw whatever error <tt>socket.connect</tt> throws (Hint: don't error check on any of <tt>socket</tt>'s methods).</p>
      
      <p>Next, implement the <tt>close</tt> method to disconnect from the server and clean up the socket.</p>
<pre>
db.close()
</pre> 
      
      <p>The main part of this milestone is implementing all of EasyDB commands. You are suggested to use Python's <tt>struct</tt> library to help build packets and read responses from the server. When the server responds in error, you should throw objects of the corresponding error classes.</p>
      
      <ul>
        <li><tt>orm.ObjectDoesNotExist</tt>: corresponds to the error code <tt>NOT_FOUND</tt>.</li>
        <li><tt>orm.TableNotFound</tt>: corresponds to the error code <tt>BAD_TABLE</tt>.</li>
        <li><tt>orm.QueryError</tt>: corresponds to the error code <tt>BAD_QUERY</tt>.</li>
        <li><tt>orm.TransactionAbort</tt>: corresponds to the error code <tt>TXN_ABORT</tt>.</li>
      </ul>
      
      <p>Now, here is the specification for each command:</p>
      
      <h5>Insert Command</h5>
      <pre>insert(table_name, values)</pre>
      <p><em>table_name</em> is the name of the table, and values should be a sequence (e.g., list, tuple) of <tt>N</tt> elements where <tt>N</tt> is the number of columns in the table. You should throw a <tt>ValueError</tt> if any of the arguments have problems, such as the table name does not exist, the number of elements in <tt>values</tt> is incorrect, or one of the columns have an invalid type (i.e., must be one of the native types that EasyDB supports). If the response is OK, return a tuple of <em>id</em>, <em>version</em>. For example:</p>
      
<pre>
id, version = db.insert("User", ["Jay", "Sung", 5.5, 31])
</pre>
      
      <h5>Update Command</h5>
      <pre>insert(table_name, id, values, version=None)</pre>
      <p>Same as insert, with two more arguments, <em>id</em> and <em>version</em>. <em>id</em> is the id of the row to update, and <em>version</em> is optional, and if specified, will enable atomic update. If the response is OK, return the new <em>version</em>, regardless of whether atomic update was enabled or not.</p>
      
      <h5>Drop Command</h5>
      <pre>drop(table_name, id)</pre>
      <p><em>table_name</em> is the name of the table, and <em>id</em> is the id of the row to be deleted. This method does not return a value, but <tt>orm.ObjectDoesNotExist</tt> is raised if the id does not exist in the specified table.</p>
      
      <h5>Get Command</h5>
      <pre>get(table_name, id)</pre>
      <p><em>table_name</em> is the name of the table, and <em>id</em> is the id of the row to be retrieved. If the response is OK, return a list of the values and the version. For example:</p>

<pre>
values, version = db.insert("User", 1)
print(values)
# ['Jay', 'Sung', 5.5, 31]
</pre>
      
      <h5>Scan Command</h5>
      <pre>scan(table_name, query)</pre>
      <p><em>table_name</em> is the name of the table, and <em>query</em> is a tuple of 3 elements: name of column, the operator, and the right operand, in that order. Similar to insert, <tt>ValueError</tt> should be thrown if the column name does not exist, operator is not supported, or the right operand is the wrong data type. If the response is OK, return a list of all matching ids (may be empty). For example:</p>

<pre>
results = db.scan("Account", ("balance", easydb.OP_GT, 10000))
print(results)
# [1, 3, 7]
</pre>

      <h4 id="orm_schema">Database Model</h4>
      <p>In an object-relational mapping software, the programmer would write their database schema in a database-neutral language (i.e., in a way that the underlying database could be swapped out without affecting the program). For our ORM, the programmer will write the schema in Python (inspired by <a href="https://www.djangoproject.com/">Django</a>). Let's first look at an example schema:</p>
      
<pre>
# schema.py

import orm

class User(orm.Table):
    firstName = orm.String()
    lastName = orm.String()
    height = orm.Float(blank=True)
    age = orm.Integer(blank=True)
    
    def __repr__(self):
      return "&lt;User: %s %s&gt;"%(self.firstName, self.lastName)
    
class Account(orm.Table):
    user = orm.Foreign(User)
    type = orm.String(choices=["Savings", "Chequing",], default="Chequing")
    balance = orm.Float()
</pre> 
     
      <p>For all database tables, the client will inherit <tt>orm.Table</tt>. For each column in the table, it is presented by an instance of one of the following classes: <tt>String</tt>, <tt>Integer</tt>, <tt>Float</tt>, and <tt>Foreign</tt>. Each of these classes corresponds to a primitive type that EasyDB supports. For the first three classes, there are no parameters. For <tt>Foreign</tt>, it takes one parameter: the class of the referenced table. For later part of this assignment, you will be adding new field types and building them on top of the primitive types.</p>
      
      <p>Every field types support the following options:</p>
      
      <ul>
        <li><b>blank</b>: this field is allowed to be left unspecified when creating new objects. When this option is set to False (which is the default), <tt>AttributeError</tt> will be raised when database insert is attempted if the field is not specified. Otherwise, default value of the type (e.g. 0 for int, "" for string) will automatically be used for objects with the field missing.</li>
        <li><b>default</b>: the default value for this field if it is unspecified in the constructor. Unlike <tt>blank</tt>, <tt>default</tt> will automatically set the missing attribute to the default value. For <tt>blank</tt>, the field will be set to <tt>None</tt> for new objects before it is saved.</li>
        <li><b>choices</b>: a list of allowed values for this field. <tt>ValueError</tt> will be raised if the field has value not in <tt>choices</tt> when insert or update is attempted.</li>
      </ul>
      <p>Our ORM provides two interfaces to initialize the underlying database client.</p>

<h5>Setup</h5>
<pre>
orm.setup(database_name, module)
</pre>
      <p><em>setup</em> will return a database object that is initialized, but not yet connected. <em>database_name</em> is the name of the underlying database implementation. Currently, we only support one argument: "easydb". <em>module</em> is the module that contains the schema (e.g. schema.py). </p>
<pre>
import schema
db = orm.setup("easydb", schema)  # this should create easydb.Database
db.connect("127.0.0.1", 8080)
</pre>

<h5>Export</h5>
<pre>
orm.export(database_name, module)
</pre>
      <p><em>export</em> will return a string which can be read by the underlying database to create the corresponding database tables, each with the specified columns, similar to the example shown in the <a href="#schema">Database Schema</a> section. This feature is helpful so that you do not have to write the database schema manually in EasyDB format on top of writing the Python ORM format.</p>
         
      <h4 id="methods">Table Methods</h4>
      
      <p>For each table in the schema, the following class methods are defined. For each of these methods, Table should be replaced by the actual Table in the schema (e.g., User, Account).</p>
      
      <h5>Object Interface</h5>
<pre>
object = Table(...)
</pre>      
      <p>Create a new object (row) of type Table. The constructor accepts keyword arguments which are the column names of the table. Default values are used for unspecified columns. For example:</p>
<pre>
# joe.lastName is None, joe.height is 0.0
joe = User(firstName="Joe", age=32)
</pre>

      <p>Each instance has the following attributes on top of the column fields:</p>
      <ul>
        <li><b>save</b>: Saves the object to the database. For new objects in EasyDB, this will call <tt>insert</tt>. For existing objects, this will call <tt>update</tt>. For fields where <tt>blank</tt> is true, saving the object will convert the value from <tt>None</tt> to the default type value. <tt>save</tt> takes an optional parameter, <tt>atomic</tt>, which is by default true. If set to false, disables atomic update for that save.</li>
        <li><b>delete</b>: Deletes the object. In EasyDB, this will call the <tt>drop</tt> command.</li>
        <li><b>pk</b>: the id of the object (i.e. primary key). This field is <tt>None</tt> before it is in the database.</li>
        <li><b>version</b>: the version of the object. This field is <tt>None</tt> before it is in the database.</li>
      </ul>
      <p>Here is an example of an object's usage, continuing from the above example:</p>
<pre>
joe.pk is None    # True
joe.height == 0.  # True
joe.save()        # AttributeError: lastName is not specified
joe.lastName = "Smith"
joe.save()
joe.pk            # 2 (the id of the object)
joe.version       # 1 (the version of the object)
joe.age = 33
joe.save(atomic=False)    # disable atomic update for this call to easydb.update
joe.version               # 2 (new version of the object)
joe.age = 34
joe.save()                # this will call easydb.update, which may raise TransactionAbort
joe.delete()              # deletes the row from the database
</pre>

      <p>All foreign key references are converted automatically to their objects. Hint: you can implement this lazily (only retrieve from database when field is accessed), or eagerly (retrieve foreign keys during the get ORM operation). You should raise <tt>IntegrityError</tt> if the referenced object is not in the database.</p>
      
<pre>
account = Account.get(pk=2)
account.user  # &lt;User: Joe Smith&gt;
</pre>
      
<h5>Get Method</h5>  
<pre>
object = Table.get(pk)
</pre>
      <p>Returns an existing object from the table, if it exists. The returned object has the same interface as above, with pk and version already set.</p>

<h5>Filter Method</h5>
<pre>
[object...] = Table.filter(...)
</pre>
      <p>Returns a list of objects that matches the query. If no argument is given, returns all objects in the table. The query arguments uses the following format: <em>columnname__op</em>=<em>value</em> where <em>columnname</em> is the column name of the object, <em>op</em> is the operator, and <em>value</em> is the right operand. For the equality operator, <em>__eq</em> is not needed. For example:</p>
      
<pre>
results = Table.filter(age__gt=33)
...
results = Table.filter(firstName="Joe")
results # [&lt;User: Joe Smith&gt;]
</pre>      
      
      <p>The supported operators are <tt>ne</tt> (not equal), <tt>gt</tt> (greater than), and <tt>lt</tt> (less than). When the field is a foreign key, you can use either the object itself or its id. For example:</p>

<pre>
results = Account.filter(user=joe)
# or
results = Account.filter(user=2)
</pre>  
      
<h5>Count Method</h5>
<pre>
number = Table.count(...)
</pre>  
      <p>Returns the number of matches given the query. If no argument is given, returns the number of rows in the table. The query format is the same as above.</p>
      
      <h4 id="custom_types">Custom Types</h4>
      
      <p>In this section, you will build custom field types that is not natively supported by the underlying database. Your ORM layer will seamlessly convert to and from the database's storage type, and perform type safety checks as is required.</p>
      
      <h5>Datetime Field</h5>
      <p>Create a new field, <tt>DateTime</tt>, which is represented in Python by a datetime.datetime instance. For example:</p>
      
<pre>
# schema.py
import orm
from datetime import datetime

class Lecture(orm.Table):
    location = orm.String()
    start = orm.DateTime(default=datetime.now)
    end = orm.DateTime()

# main.py
ece326 = Lecture(location="BA1190")
ece326.start = datetime(2019, 10, 15, 12)
ece326.end = datetime(2019, 10, 15, 13)
ece326.save()
</pre>       
      <p>For the default value, you must support calling a function if <tt>default</tt> is assigned a function. For the datetime instance, you can ignore time zone related settings.</p>
      
      <p>Hint: store it in <a href="https://docs.python.org/3.3/library/datetime.html#datetime.datetime.timestamp">POSIX timestamp</a> format.</p>
      
      <h5>Coordinate Field</h5>
      <p>Create a new field, <tt>Coordinate</tt>, which is represented in Python by a 2-tuple, and must be a valid <a href="https://en.wikipedia.org/wiki/Geographic_coordinate_system">geographic coordinate</a> in latitude and longitude. For example:</p>

<pre>      
class Capital(orm.Table):
    name = orm.String()
    location = orm.Coordinate()      

# main.py
ottawa = Capital.filter(name="Ottawa")[0]
ottawa.location   #(45.4215, 75.6972)      
</pre>
      <p>If the coordinate is invalid, you must raise <tt>ValueError</tt> when save or update is attempted. You only need to support equality and inequality operator when this field is queried. You may assume that you will always read back a valid coordinate from the database.</p>
      
      <p>Hint: store it using two native EasyDB fields.</p>
 
      <h4 id="submission">Code Submission</h4>
      <p>To submit your code with the current commit, use the <tt>Asst3-end</tt> tag. Remember to push the new tag to the remote repository.</p>
 
<pre>
git tag Asst3-end    // Creates tag for current submission for Assignment 3
git push --tags
</pre>
      
      <h4 id="glossary">Glossary of Terms</h4>
      <p>Here, you can find the definition of commonly seen terms that are used in the assignment. More will be added as people ask questions about the assignment.</p>
      
      <ul>
        <li><b>table</b>: a group of data with the same user-defined format, similar to a class in object-oriented programming.</li>
        <li><b>row</b>: a record in a database table, similar to an instance of a class.</li>
        <li><b>column</b>: a "field" in a database row, with an associated name.</li>
      </ul>
      
      <hr>
      <footer class="container text-center">
        <p>&copy; 2019 Kuei (Jack) Sun, University of Toronto</p>
      </footer>
    </main>
  </div>
</div>

<script src="js/jquery-3.4.1.min.js"></script>
<script src="js/bootstrap.min.js"></script>
<script type="text/javascript">
  $(document).ready(function() {
    /* nothing for now */
  });
</script>
</body>
</html>